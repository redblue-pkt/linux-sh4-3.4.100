menu "Memory management options"

config QUICKLIST
	def_bool y

config MMU
        bool "Support for memory management hardware"
	depends on !CPU_SH2
	default y
	help
	  Some SH processors (such as SH-2/SH-2A) lack an MMU. In order to
	  boot on these systems, this option must not be set.

	  On other systems (such as the SH-3 and 4) where an MMU exists,
	  turning this off will boot the kernel on these machines with the
	  MMU implicitly switched off.

config PAGE_OFFSET
	hex
	default "0x80000000" if MMU && SUPERH32
	default "0x20000000" if MMU && SUPERH64
	default "0x00000000"

config FORCE_MAX_ZONEORDER
	int "Maximum zone order"
	range 9 64 if PAGE_SIZE_16KB
	default "9" if PAGE_SIZE_16KB
	range 7 64 if PAGE_SIZE_64KB
	default "7" if PAGE_SIZE_64KB
	range 11 64
	default "14" if !MMU
	default "11"
	help
	  The kernel memory allocator divides physically contiguous memory
	  blocks into "zones", where each zone is a power of two number of
	  pages.  This option selects the largest power of two that the kernel
	  keeps in the memory allocator.  If you need to allocate very large
	  blocks of physically contiguous memory, then you may need to
	  increase this value.

	  This config option is actually maximum order plus one. For example,
	  a value of 11 means that the largest free memory block is 2^10 pages.

	  The page size is not necessarily 4KB. Keep this in mind when
	  choosing a value for this option.

config MEMORY_START
	hex "Physical memory start address"
	default "0x08000000"
	---help---
	  Computers built with Hitachi SuperH processors always
	  map the ROM starting at address zero.  But the processor
	  does not specify the range that RAM takes.

	  The physical memory (RAM) start address will be automatically
	  set to 08000000. Other platforms, such as the Solution Engine
	  boards typically map RAM at 0C000000.

	  Tweak this only when porting to a new machine which does not
	  already have a defconfig. Changing it from the known correct
	  value on any of the known systems will only lead to disaster.

config MEMORY_SIZE
	hex "Physical memory size"
	default "0x04000000"
	help
	  This sets the default memory size assumed by your SH kernel. It can
	  be overridden as normal by the 'mem=' argument on the kernel command
	  line. If unsure, consult your board specifications or just leave it
	  as 0x04000000 which was the default value before this became
	  configurable.

# Physical addressing modes

config 29BIT
	def_bool !32BIT
	depends on SUPERH32
	select UNCACHED_MAPPING

config 32BIT
	bool
	default y if CPU_SH5 || !MMU

config SUPPORTS_32BIT
	bool
	default n

config PMB
	bool "Support 32-bit physical addressing through PMB"
	depends on MMU && EXPERIMENTAL && SUPPORTS_32BIT
	select 32BIT
	select UNCACHED_MAPPING
	help
	  If you say Y here, physical addressing will be extended to
	  32-bits through the SH-4A PMB. If this is not set, legacy
	  29-bit physical addressing will be used.

choice
	prompt "PMB implementation"
	depends on PMB
	default PMB_ST if CPU_SUBTYPE_ST40
	default PMB_RENESAS if !CPU_SUBTYPE_ST40

config PMB_ST
	bool "STMicroelectronics"
	help
	  This selects the STMicroelectronics PMB implementation.
	  This requires one uncached mapping to be present at boot time.
	  It also uses more sophisticated algorithms to try to make optimal
	  use of the PMBs. Ideally the ST and Renesas implementations should
	  be merged, but this is tricky to do without testing on both platforms.

config PMB_RENESAS
	bool "Renesas"
	help
	  This selects the Renesas implementation of PMB support.
	  This requires that two PMB mappings are present at boot,
	  a cached and uncached mapping at 80000000 and A0000000 mirroring
	  the 29 bit legacy setup.

endchoice

config PMB_64M_TILES
	bool "Tile P1/P2 region with 64M PMB entries"
	depends on PMB_ST
	help
	  PMB lookups are architecturally defined such that if a miss
	  occurs when accessing the P1/P2 region a reset will occur.
	  This can make debugging kernel code very difficult, as a
	  stray pointer will cause a reset rather than an exception as
	  on most other architectures.

	  To help with this problem, this option can be enabled which
	  ensures that the entire P1/P2 region is always filled with
	  PMB entries, so that a PMB miss can never occur.

	  The disadvantags of enabing this option is that only 64M PMB
	  entries can be used, as this the only way to guantee that
	  there will always be sufficient PMB entries to fill the
	  P1/P2 virtual region. This may mean that some PMB
	  configurations which work without this option enabled fail
	  when it is enabled.

	  The second disadvantage is that the mappings created in this
	  way are completly valid for read and write accesses (there
	  is no way to cause an exception on a PMB hit either).
	  Entries configured in this way can be mapped to any chosen
	  physical address, using the option PMB_64M_TILES_PHYS
	  below, which defaults to the start of kernel memory, which
	  may cause corruption of code or data in this region if a
	  invalid address is written to. It may be possible to choose
	  another address which is less damaging, but that will depend
	  on the SoC and application.

config PMB_64M_TILES_PHYS
	hex "PMB workaround physical memory start address"
	depends on PMB_64M_TILES
	default MEMORY_START
	help
	  The physical address to be used for any PMB mappings used to
	  fill in holes in the virtual address space when PMB_64M_TILES
	  is enabled.

config PMB_LARGE_UNCACHED_MAPPING
	bool "Map all of kernel memory uncached using the PMB"
	depends on PMB
	help
	  Normally when the kernel boots it maps the entire kernel logical
	  memory region into the kernel's address space using the PMB.
	  A small uncached region is also created to map some key functions
	  which must be executed from uncached code. In some circumstances
	  it might be useful to have this uncached region expanded to cover
	  the entire kernel memory space, for example if the P1/P2 portion
	  of the address space has very little free space, and it is known
	  that this uncached mapping will be needed later.

	  Note that on systems with more than 512MB kernel memory this will
	  prevent the system booting, so should not be enabled.

config X2TLB
	def_bool y
	depends on (CPU_SHX2 || CPU_SHX3) && MMU

config VSYSCALL
	bool "Support vsyscall page"
	depends on MMU && (CPU_SH3 || CPU_SH4)
	default y
	help
	  This will enable support for the kernel mapping a vDSO page
	  in process space, and subsequently handing down the entry point
	  to the libc through the ELF auxiliary vector.

	  From the kernel side this is used for the signal trampoline.
	  For systems with an MMU that can afford to give up a page,
	  (the default value) say Y.

config NUMA
	bool "Non Uniform Memory Access (NUMA) Support"
	depends on MMU && SYS_SUPPORTS_NUMA && EXPERIMENTAL
	default n
	help
	  Some SH systems have many various memories scattered around
	  the address space, each with varying latencies. This enables
	  support for these blocks by binding them to nodes and allowing
	  memory policies to be used for prioritizing and controlling
	  allocation behaviour.

config NODES_SHIFT
	int
	default "3" if CPU_SUBTYPE_SHX3
	default "1"
	depends on NEED_MULTIPLE_NODES

config ARCH_FLATMEM_ENABLE
	def_bool y
	depends on !NUMA

config ARCH_SPARSEMEM_ENABLE
	def_bool y
	select SPARSEMEM_STATIC

config ARCH_SPARSEMEM_DEFAULT
	def_bool y

config MAX_ACTIVE_REGIONS
	int
	default "6" if (CPU_SUBTYPE_SHX3 && SPARSEMEM)
	default "2" if SPARSEMEM && (CPU_SUBTYPE_SH7722 || \
		       CPU_SUBTYPE_SH7785)
	default "1"

config ARCH_SELECT_MEMORY_MODEL
	def_bool y

config ARCH_ENABLE_MEMORY_HOTPLUG
	def_bool y
	depends on SPARSEMEM && MMU

config ARCH_ENABLE_MEMORY_HOTREMOVE
	def_bool y
	depends on SPARSEMEM && MMU

config ARCH_MEMORY_PROBE
	def_bool y
	depends on MEMORY_HOTPLUG

config IOREMAP_FIXED
       def_bool y
       depends on X2TLB || SUPERH64

config UNCACHED_MAPPING
	bool

config HAVE_SRAM_POOL
	bool
	select GENERIC_ALLOCATOR

choice
	prompt "Kernel page size"
	default PAGE_SIZE_4KB

config PAGE_SIZE_4KB
	bool "4kB"
	help
	  This is the default page size used by all SuperH CPUs.

config PAGE_SIZE_8KB
	bool "8kB"
	depends on !MMU || X2TLB
	help
	  This enables 8kB pages as supported by SH-X2 and later MMUs.

config PAGE_SIZE_16KB
	bool "16kB"
	depends on !MMU
	help
	  This enables 16kB pages on MMU-less SH systems.

config PAGE_SIZE_64KB
	bool "64kB"
	depends on !MMU || CPU_SH4 || CPU_SH5
	help
	  This enables support for 64kB pages, possible on all SH-4
	  CPUs and later.

endchoice

choice
	prompt "HugeTLB page size"
	depends on HUGETLB_PAGE
	default HUGETLB_PAGE_SIZE_1MB if PAGE_SIZE_64KB
	default HUGETLB_PAGE_SIZE_64K

config HUGETLB_PAGE_SIZE_64K
	bool "64kB"
	depends on !PAGE_SIZE_64KB

config HUGETLB_PAGE_SIZE_256K
	bool "256kB"
	depends on X2TLB

config HUGETLB_PAGE_SIZE_1MB
	bool "1MB"

config HUGETLB_PAGE_SIZE_4MB
	bool "4MB"
	depends on X2TLB

config HUGETLB_PAGE_SIZE_64MB
	bool "64MB"
	depends on X2TLB

config HUGETLB_PAGE_SIZE_512MB
	bool "512MB"
	depends on CPU_SH5

endchoice

source "mm/Kconfig"

config SCHED_MC
	bool "Multi-core scheduler support"
	depends on SMP
	default y
	help
	  Multi-core scheduler support improves the CPU scheduler's decision
	  making when dealing with multi-core CPU chips at a cost of slightly
	  increased overhead in some places. If unsure say N here.

endmenu

menu "Cache configuration"

config SH7705_CACHE_32KB
	bool "Enable 32KB cache size for SH7705"
	depends on CPU_SUBTYPE_SH7705
	default y

choice
	prompt "Cache mode"
	default CACHE_WRITEBACK if CPU_SH2A || CPU_SH3 || CPU_SH4 || CPU_SH5
	default CACHE_WRITETHROUGH if (CPU_SH2 && !CPU_SH2A)

config CACHE_WRITEBACK
	bool "Write-back"

config CACHE_WRITETHROUGH
	bool "Write-through"
	help
	  Selecting this option will configure the caches in write-through
	  mode, as opposed to the default write-back configuration.

	  Since there's sill some aliasing issues on SH-4, this option will
	  unfortunately still require the majority of flushing functions to
	  be implemented to deal with aliasing.

	  If unsure, say N.

config CACHE_OFF
	bool "Off"

endchoice

config STM_L2_CACHE
	bool "STM Level-2 cache support"
	depends on CPU_ST40_300
	help
	  Selecting this option will enable support for Level-2
	  cache present in some of the STMicroelectronics SOCs.

choice
	prompt "Default Level-2 cache mode"
	depends on STM_L2_CACHE
	default STM_L2_CACHE_WRITEBACK
	help
	  Select a mode the Level-2 cache should be configured by
	  default. This may be changed in runtime using
	  "/sys/kernel/mm/l2/mode" file.

config STM_L2_CACHE_BYPASSED
	bool "Bypassed"

config STM_L2_CACHE_WRITETHROUGH
	bool "Write-through"

config STM_L2_CACHE_WRITEBACK
	bool "Write-back"

endchoice

endmenu
